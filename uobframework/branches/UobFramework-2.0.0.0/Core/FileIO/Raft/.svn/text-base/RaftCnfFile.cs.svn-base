using System;
using System.IO;
using System.Text;

using UoB.Core.Structure;
using UoB.Core.MoveSets.AngleSets;

namespace UoB.Core.FileIO.Raft
{
	/// <summary>
	/// Summary description for RaftCnfFile.
	/// </summary>
	public class RaftCnfFile
	{
		private RaftCnfFile()
		{
		}


		public static int Write_OnlyAnglesInSameConfRegionAsNative( string filename, AngleSet angleSet, PolyPeptide mol )
		{
			// best conformer - how many conformations does that give
			int[] nearestConformer = angleSet.GetBestConformer( mol );
			
			string sequence = mol.MonomerString;
			int seqLength = sequence.Length;

			int confCount = angleSet.TotalNumberOfAnglesInClassOf( sequence[0], nearestConformer[0] );
			for( int i = 1; i < seqLength; i++ )
			{
				confCount *= angleSet.TotalNumberOfAnglesInClassOf( sequence[i], nearestConformer[i] );
			}

			// setup required filestream and builder
			StreamWriter rw = new StreamWriter( filename );
			StringBuilder build = new StringBuilder( seqLength );
			for( int i = 0; i < seqLength; i++ )
			{
				build.Append('0');
			}

			// write the pre-amble
			rw.WriteLine("%CONFORMER FILE");
			rw.WriteLine("%VERSION  1.0");
			rw.WriteLine("#DAVE autogenerated RAFT CONFORMER file");
			rw.Write( "         0" );
			rw.Write( seqLength.ToString().PadLeft(10,' ') );
			rw.WriteLine( confCount.ToString().PadLeft(10,' ') );

			// now do the conformers

			DoConfGlobalBin( rw, angleSet, build, sequence, nearestConformer, 0 );

			rw.Close();

			return confCount;
		}

		public static int Write( string fileName, AngleSet angleSet, int length )
		{
			return Write( fileName, angleSet, length, 0, -1 ); // add with no anchor at either end ...
		}

		public static int Write( string fileName, AngleSet angleSet, int length, int anchorLength, int raftAnchorID )
		{
			throw new Exception("THIS CLASS ASSUMES 6 ANGLES, needs to be rewritten to take a sequence and an angle set ...");
			//%CONFORMER FILE
			//%VERSION  1.0
			//# random conformers produced by RAFT, format of
			//# next line is 3i10, nval, nlen, nconfs
			//         1        65     10000
			//     5.126 35345624511145153542352611555553415333155311161316452545235542511
			//     5.447 55425214132543565252252543454552322453415154312522115254254551555
			//     5.447 55425214132543565252252542454552322453415154312522115254254551555

//			if( raftAnchorID < 1 || raftAnchorID > 6 )
//			{
//				throw new Exception("raftAnchorID is invalid");
//			}
//			if( (anchorLength * 2) >= (length + 2) )
//			{
//				throw new Exception("Anchor lengths dont make sense");
//			}
//
//			// setup required filestreams and stringbuilders
//
//			StreamWriter rw = new StreamWriter( filename );
//			StringBuilder build = new StringBuilder( length );
//
//			// write the pre-amble
//
//			rw.WriteLine("%CONFORMER FILE");
//			rw.WriteLine("%VERSION  1.0");
//			rw.WriteLine("#DAVE autogenerated RAFT CONFORMER file");
//			rw.Write( "         0" );
//			rw.Write( length.ToString().PadLeft(10,' ') );
//			int confCount = (int) Math.Pow( 6.0, (double) length );
//			rw.WriteLine( confCount.ToString().PadLeft(10,' ') );
//
//			// now do the conformers
//
//			int countTo = length - anchorLength;
//
//			for( int i = 0; i < anchorLength; i++ )
//			{
//				build.Append( raftAnchorID.ToString() );
//			}
//			for( int i = anchorLength; i < countTo; i++ )
//			{
//				build.Append( '1' );
//			}
//			for( int i = 0; i < anchorLength; i++ )
//			{
//				build.Append( raftAnchorID.ToString() );
//			}
//
//			DoConf( rw, build, anchorLength, length - (2*anchorLength), 0 );
//
//			rw.Close();
//
//			return confCount;
		}

		
		private static void DoConfGlobalBin( StreamWriter rw, AngleSet angleSet, StringBuilder build, string sequence, int[] idealConf, int currentIndex )
		{
			int[] confsInSameBin = angleSet.ConformersInSameBinAs_RAFTEXPLICIT( sequence[currentIndex], idealConf[currentIndex] );

			for( int k = 0; k < confsInSameBin.Length; k++ )
			{
				build[currentIndex] = confsInSameBin[k].ToString()[0];
				if( currentIndex + 1 < idealConf.Length )
				{
					DoConfGlobalBin( rw, angleSet, build, sequence, idealConf, currentIndex + 1 );
				}
				else
				{
					rw.WriteLine( build.ToString() );
				}
			}			
		}

		// recursive function, say wooooo
		private static void DoConf( StreamWriter rw, StringBuilder build, int startID, int length, int currentIndex )
		{
			for( int k = 1; k <= 6; k++ )
			{
				build[startID+currentIndex] = k.ToString()[0];
				if( currentIndex + 1 < length )
				{
					DoConf( rw, build, startID, length, currentIndex + 1 );
				}
				else
				{
					rw.WriteLine( build.ToString() );
				}
			}
		}		
	}
}
